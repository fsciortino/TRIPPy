% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{TRIPPy Documentation}
\date{May 01, 2014}
\release{1.0}
\author{Ian Faust}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{TRIPPy::doc}



\chapter{Subpackages}
\label{TRIPPy:trippy-package}\label{TRIPPy:subpackages}

\section{TRIPPy.plot package}
\label{TRIPPy.plot:trippy-plot-package}\label{TRIPPy.plot::doc}

\subsection{Submodules}
\label{TRIPPy.plot:submodules}

\subsection{TRIPPy.plot.plot module}
\label{TRIPPy.plot:module-TRIPPy.plot.plot}\label{TRIPPy.plot:trippy-plot-plot-module}\index{TRIPPy.plot.plot (module)}\index{genCartGrid() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.genCartGrid}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{genCartGrid}}{\emph{x0}, \emph{x1}, \emph{x2}, \emph{edges=False}}{}
\end{fulllineitems}

\index{genCylGrid() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.genCylGrid}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{genCylGrid}}{\emph{x0}, \emph{x1}, \emph{x2}, \emph{edges=False}}{}
\end{fulllineitems}

\index{genVertsFromPixel() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.genVertsFromPixel}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{genVertsFromPixel}}{\emph{grid}}{}
reduces the lengths of the dimensions by 1

\end{fulllineitems}

\index{plotLine() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.plotLine}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{plotLine}}{\emph{vector}, \emph{val=1.0}, \emph{close=False}, \emph{tube\_radius=None}, \emph{index=None}, \emph{**kwargs}}{}
PlotLine creates a single plot object from a singular vector or from a n-dimensional
tuple or list.

\end{fulllineitems}

\index{plotSymIso() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.plotSymIso}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{plotSymIso}}{\emph{plasma}, \emph{pts=15}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{plotTangency() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.plotTangency}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{plotTangency}}{\emph{plasma}, \emph{beam}}{}
nonlinear minimization of r\textasciicircum{}2 between the plasma center (in R,Z) versus defined beam s
vector

\end{fulllineitems}

\index{plotTokamak() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.plotTokamak}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{plotTokamak}}{\emph{tokamak, angle={[}0, 6.283185307179586{]}, pts=250, section=None, **kwargs}}{}
\end{fulllineitems}

\index{plotView() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.plotView}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{plotView}}{\emph{rays}, \emph{pts=None}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{plotVol() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.plotVol}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{plotVol}}{\emph{volume}, \emph{pts=15}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{plotVol2() (in module TRIPPy.plot.plot)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy.plot:TRIPPy.plot.plot.plotVol2}\pysiglinewithargsret{\code{TRIPPy.plot.plot.}\bfcode{plotVol2}}{\emph{plasma}, \emph{pts=None}, \emph{lim=False}, \emph{**kwargs}}{}
\end{fulllineitems}



\subsection{Module contents}
\label{TRIPPy.plot:module-TRIPPy.plot}\label{TRIPPy.plot:module-contents}\index{TRIPPy.plot (module)}

\chapter{Submodules}
\label{TRIPPy:submodules}

\chapter{TRIPPy.AXUV module}
\label{TRIPPy:trippy-axuv-module}\label{TRIPPy:module-TRIPPy.AXUV}\index{TRIPPy.AXUV (module)}\index{AXUV20() (in module TRIPPy.AXUV)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.AXUV.AXUV20}\pysiglinewithargsret{\code{TRIPPy.AXUV.}\bfcode{AXUV20}}{\emph{temp}}{}
\end{fulllineitems}

\index{AXUV22() (in module TRIPPy.AXUV)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.AXUV.AXUV22}\pysiglinewithargsret{\code{TRIPPy.AXUV.}\bfcode{AXUV22}}{\emph{temp}}{}
temp

\end{fulllineitems}



\chapter{TRIPPy.BPLY module}
\label{TRIPPy:module-TRIPPy.BPLY}\label{TRIPPy:trippy-bply-module}\index{TRIPPy.BPLY (module)}\index{BPLY() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.BPLY}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{BPLY}}{\emph{temp}, \emph{place=(1.87}, \emph{0}, \emph{0.157277)}, \emph{angle=(0}, \emph{1.7453263267948966}, \emph{-0.05305367320510346)}}{}
\end{fulllineitems}

\index{BPLYbeam() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.BPLYbeam}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{BPLYbeam}}{\emph{alcator}}{}
\end{fulllineitems}

\index{calcArea() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.calcArea}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{calcArea}}{\emph{points}}{}
\end{fulllineitems}

\index{calctoTree() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.calctoTree}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{calctoTree}}{\emph{shot}}{}
\end{fulllineitems}

\index{effectiveHeight() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.effectiveHeight}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{effectiveHeight}}{\emph{surf1}, \emph{surf2}, \emph{plasma}, \emph{t}, \emph{lim1=0.88}, \emph{lim2=0.92}}{}
calculate the effective height of a view through the scrape-off-layer

\end{fulllineitems}

\index{getBeamFluxSpline() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.getBeamFluxSpline}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{getBeamFluxSpline}}{\emph{beam}, \emph{plasma}, \emph{t}, \emph{lim1}, \emph{lim2}, \emph{points=1000}}{}
generates a spline off of the beampath.  Assumes
that the change in flux is MONOTONIC

\end{fulllineitems}

\index{globalpowerCalc() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.globalpowerCalc}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{globalpowerCalc}}{\emph{shot}}{}
\end{fulllineitems}

\index{trend() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.trend}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{trend}}{\emph{tree}, \emph{signal}, \emph{shot}}{}
\end{fulllineitems}

\index{viewPoints() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.viewPoints}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{viewPoints}}{\emph{surf1}, \emph{surf2}, \emph{plasma}, \emph{t}, \emph{lim1=0.88}, \emph{lim2=0.92}, \emph{fillorder=True}}{}
\end{fulllineitems}

\index{writeGlobal() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.writeGlobal}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{writeGlobal}}{\emph{shot}}{}
\end{fulllineitems}

\index{writeToTree() (in module TRIPPy.BPLY)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.BPLY.writeToTree}\pysiglinewithargsret{\code{TRIPPy.BPLY.}\bfcode{writeToTree}}{\emph{inp}}{}
\end{fulllineitems}



\chapter{TRIPPy.CmodTS module}
\label{TRIPPy:module-TRIPPy.CmodTS}\label{TRIPPy:trippy-cmodts-module}\index{TRIPPy.CmodTS (module)}\index{Chords() (in module TRIPPy.CmodTS)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.CmodTS.Chords}\pysiglinewithargsret{\code{TRIPPy.CmodTS.}\bfcode{Chords}}{\emph{plasma}}{}
\end{fulllineitems}



\chapter{TRIPPy.NSTX module}
\label{TRIPPy:module-TRIPPy.NSTX}\label{TRIPPy:trippy-nstx-module}\index{TRIPPy.NSTX (module)}\index{diode1() (in module TRIPPy.NSTX)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.NSTX.diode1}\pysiglinewithargsret{\code{TRIPPy.NSTX.}\bfcode{diode1}}{\emph{temp}, \emph{place=(2.0}, \emph{0}, \emph{0.02)}, \emph{angle=(0}, \emph{1.5707963267948966}, \emph{0)}}{}
\end{fulllineitems}

\index{diode2() (in module TRIPPy.NSTX)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.NSTX.diode2}\pysiglinewithargsret{\code{TRIPPy.NSTX.}\bfcode{diode2}}{\emph{temp}, \emph{place=(2.0}, \emph{0}, \emph{-0.02)}, \emph{angle=(0}, \emph{1.5707963267948966}, \emph{0)}}{}
\end{fulllineitems}

\index{diode3() (in module TRIPPy.NSTX)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.NSTX.diode3}\pysiglinewithargsret{\code{TRIPPy.NSTX.}\bfcode{diode3}}{\emph{temp}, \emph{place=(0.8}, \emph{0}, \emph{1.8)}, \emph{angle=(0}, \emph{1.5707963267948966}, \emph{0)}}{}
\end{fulllineitems}

\index{diode4() (in module TRIPPy.NSTX)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.NSTX.diode4}\pysiglinewithargsret{\code{TRIPPy.NSTX.}\bfcode{diode4}}{\emph{temp}, \emph{place=(1.5}, \emph{0}, \emph{-1.5)}, \emph{angle=(0}, \emph{1.5707963267948966}, \emph{0)}}{}
\end{fulllineitems}

\index{diode5() (in module TRIPPy.NSTX)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.NSTX.diode5}\pysiglinewithargsret{\code{TRIPPy.NSTX.}\bfcode{diode5}}{\emph{center}, \emph{ap=(0.002}, \emph{0}, \emph{0.08)}}{}
\end{fulllineitems}

\index{diode6() (in module TRIPPy.NSTX)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.NSTX.diode6}\pysiglinewithargsret{\code{TRIPPy.NSTX.}\bfcode{diode6}}{\emph{center}, \emph{ap=(0.0225}, \emph{0}, \emph{0.08)}, \emph{angler=(0}, \emph{0}, \emph{0)}}{}
\end{fulllineitems}



\chapter{TRIPPy.XTOMO module}
\label{TRIPPy:trippy-xtomo-module}\label{TRIPPy:module-TRIPPy.XTOMO}\index{TRIPPy.XTOMO (module)}\index{XTOMOchip() (in module TRIPPy.XTOMO)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.XTOMO.XTOMOchip}\pysiglinewithargsret{\code{TRIPPy.XTOMO.}\bfcode{XTOMOchip}}{\emph{temp}}{}
\end{fulllineitems}



\chapter{TRIPPy.beam module}
\label{TRIPPy:module-TRIPPy.beam}\label{TRIPPy:trippy-beam-module}\index{TRIPPy.beam (module)}\index{Beam (class in TRIPPy.beam)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam}\pysiglinewithargsret{\strong{class }\code{TRIPPy.beam.}\bfcode{Beam}}{\emph{surf1}, \emph{surf2}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.geometry.Origin]{\code{TRIPPy.geometry.Origin}}}

Generates a Beam vector object assuming macroscopic surfaces

Uses the definition:
\begin{gather}
\begin{split}\vec{x}= \vec{x}_0 + \vec{x}_1\end{split}\notag
\end{gather}\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{surf1: Surface or Surface-derived object}] \leavevmode
Defines the origin surface, based on the coordinate system
of the surface.  Center position is accessible through Beam(0).
Generated beam contains same origin as from surf1.

\item[{surf2: Surface or Surface-derived object}] \leavevmode
Defines the aperature surface, based on the coordinate system
of the surface. Both surfaces must be in the same coordinate
system.

\end{description}

\item[{Returns:}] \leavevmode
Beam: Beam object.

\item[{Examples:}] \leavevmode
Accepts all surface or surface-derived object inputs, though all data 
is stored as a python object.

Generate an y direction Ray in cartesian coords using a Vec from (0,0,1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cen} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Center}\PYG{p}{(}\PYG{n}{flag}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ydir} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Vecx}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zpt} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Point}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{cen}\PYG{p}{)}
\end{Verbatim}

\end{description}
\index{c() (TRIPPy.beam.Beam method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam.c}\pysiglinewithargsret{\bfcode{c}}{}{}
Conversion of vector to opposite coordinate system
\begin{description}
\item[{Returns:}] \leavevmode
copy of vector object with opposite coordinate system
(set with .flag parameter)

\end{description}

\end{fulllineitems}

\index{r() (TRIPPy.beam.Beam method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam.r}\pysiglinewithargsret{\bfcode{r}}{}{}
return cylindrical coordinate values
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in meters and radians

\end{description}

\end{fulllineitems}

\index{rmin() (TRIPPy.beam.Beam method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam.rmin}\pysiglinewithargsret{\bfcode{rmin}}{}{}
Calculates and returns the s value along the norm vector
which minimizes the r0() value (the closest position to the
origin norm axis)
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of s values in meters

\end{description}

\end{fulllineitems}

\index{smin() (TRIPPy.beam.Beam method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam.smin}\pysiglinewithargsret{\bfcode{smin}}{\emph{point=None}}{}
Calculates and returns the s value along the norm vector
which minimizes the distance from the ray to a point 
(default is the origin which the ray is defined).
\begin{description}
\item[{Kwargs:}] \leavevmode
point: Point or Point-derived object, otherwise defaults to ray 
origin

\item[{Returns:}] \leavevmode
numpy array of s values in meters

\end{description}

\end{fulllineitems}

\index{t() (TRIPPy.beam.Beam method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam.t}\pysiglinewithargsret{\bfcode{t}}{\emph{r}, \emph{z}}{}
return toroidal coordinate values for given cylindrical
coordinates (r,z) in coordinates of the beam origin.
\begin{description}
\item[{Args:}] \leavevmode
r: scipy-array of floats or float in meters. r is
specified in meters.

z: scipy-array of floats or float in meters. z is
specified in meters.

\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in {[}meters,radians,radians{]}
where it is radius in meters, toroidal angle and then poloidal angle.

\end{description}

\end{fulllineitems}

\index{tmin() (TRIPPy.beam.Beam method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam.tmin}\pysiglinewithargsret{\bfcode{tmin}}{\emph{r}, \emph{z}, \emph{trace=False}}{}
Calculates and returns the s value along the norm vector
which minimizes the distance from the ray to a circle defined by
input (r,z).
\begin{description}
\item[{Args:}] \leavevmode
r: value, iterable or scipy.array, radius in meters

z: value, iterable or scipy.array, z value in meters

\item[{Kwargs:}] \leavevmode
trace: bool if set true, the ray is assumed to be traced within a
tokamak.  A further evaluation reduces the value to one within
the bounds of the vacuum vessel/limiter.

\item[{Returns:}] \leavevmode
numpy array of s values in meters

\end{description}

\end{fulllineitems}

\index{x() (TRIPPy.beam.Beam method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Beam.x}\pysiglinewithargsret{\bfcode{x}}{}{}
returns array of cartesian coordinate in meters
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cartesian coordinates in meters

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Ray (class in TRIPPy.beam)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray}\pysiglinewithargsret{\strong{class }\code{TRIPPy.beam.}\bfcode{Ray}}{\emph{pt1}, \emph{inp2}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.geometry.Point]{\code{TRIPPy.geometry.Point}}}

Generates a ray vector object

Uses the definition:
\begin{gather}
\begin{split}\vec{x}= \vec{x}_0 + \vec{x}_1\end{split}\notag
\end{gather}\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{pt1: Point or Point-derived object}] \leavevmode
Defines the origin of the Ray, based on the coordinate system
of the origin.  pt1 position is accessible through Ray(0).

\item[{pt2: Point or Vector-derived object}] \leavevmode
Direction of the ray can be defined by a vector object (assumed
to be in the space of the pt1 origin) from pt1, or a point, which 
generates a vector pointing from pt1 to pt2.

\end{description}

\item[{Returns:}] \leavevmode
Ray: Ray object.

\item[{Examples:}] \leavevmode
Accepts all point and point-derived object inputs, though all data 
is stored as a python object.

Generate an y direction Ray in cartesian coords using a Vec from (0,0,1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cen} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Center}\PYG{p}{(}\PYG{n}{flag}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ydir} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Vecx}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zpt} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Point}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{cen}\PYG{p}{)}
\end{Verbatim}

\end{description}
\index{r() (TRIPPy.beam.Ray method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray.r}\pysiglinewithargsret{\bfcode{r}}{}{}
return cylindrical coordinate values
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in meters and radians

\end{description}

\end{fulllineitems}

\index{redefine() (TRIPPy.beam.Ray method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray.redefine}\pysiglinewithargsret{\bfcode{redefine}}{\emph{neworigin}}{}
redefine Ray object or Ray-derived object
into new coordinate system
\begin{description}
\item[{Args:}] \leavevmode
neworigin: Origin or Origin-derived object

\end{description}

\end{fulllineitems}

\index{rmin() (TRIPPy.beam.Ray method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray.rmin}\pysiglinewithargsret{\bfcode{rmin}}{}{}
rmin returns the s value along the norm vector which minimizes
the r0() value (the closest position to the origin norm axis)
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of s values in meters

\end{description}

\end{fulllineitems}

\index{smin() (TRIPPy.beam.Ray method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray.smin}\pysiglinewithargsret{\bfcode{smin}}{\emph{point=None}}{}
Calculates and returns the s value along the norm vector
which minimizes the distance from the ray to a point 
(default is the origin which the ray is defined).
\begin{description}
\item[{Kwargs:}] \leavevmode
point: Point or Point-derived object, otherwise defaults to ray 
origin

\item[{Returns:}] \leavevmode
numpy array of s values in meters

\end{description}

\end{fulllineitems}

\index{t() (TRIPPy.beam.Ray method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray.t}\pysiglinewithargsret{\bfcode{t}}{\emph{r}, \emph{z}}{}
return toroidal coordinate values for given cylindrical
coordinates (r,z) in coordinates of the ray origin.
\begin{description}
\item[{Args:}] \leavevmode
r: scipy-array of floats or float in meters. r is
specified in meters.

z: scipy-array of floats or float in meters. z is
specified in meters.

\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in {[}meters,radians,radians{]}
where it is radius in meters, toroidal angle and then poloidal angle.

\end{description}

\end{fulllineitems}

\index{tmin() (TRIPPy.beam.Ray method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray.tmin}\pysiglinewithargsret{\bfcode{tmin}}{\emph{r}, \emph{z}, \emph{trace=False}}{}
Calculates and returns the s value along the norm vector
which minimizes the distance from the ray to a circle defined by
input (r,z).
\begin{description}
\item[{Args:}] \leavevmode
r: value, iterable or scipy.array, radius in meters

z: value, iterable or scipy.array, z value in meters

\item[{Kwargs:}] \leavevmode
trace: bool if set true, the ray is assumed to be traced within a
tokamak.  A further evaluation reduces the value to one within
the bounds of the vacuum vessel/limiter.

\item[{Returns:}] \leavevmode
numpy array of s values in meters

\end{description}

\end{fulllineitems}

\index{x() (TRIPPy.beam.Ray method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.Ray.x}\pysiglinewithargsret{\bfcode{x}}{}{}
returns array of cartesian coordinate in meters
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cartesian coordinates in meters

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{multiBeam() (in module TRIPPy.beam)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.multiBeam}\pysiglinewithargsret{\code{TRIPPy.beam.}\bfcode{multiBeam}}{\emph{surf1}, \emph{surf2}, \emph{split=None}}{}
Generate a tuple of Beam objects from tuples of surface objects
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{surf1: tuple of Surfaces or a Surface object}] \leavevmode
Beam origin surfaces, based on the coordinate system
of the surfaces.  Center position is accessible through Beam(0),
Beam.x(){[}...,0{]} or Beam.r(){[}...,0{]} (last two options create
numpy arrays, the first generats a geometry.Vec object).

\item[{surf2: tuple of Surfaces or a Surface object}] \leavevmode
Direction of the ray can be defined by a vector object (assumed
to be in the space of the pt1 origin) from pt1, or a point, which 
generates a vector pointing from pt1 to pt2.

\end{description}

\item[{Returns:}] \leavevmode
output: tuple of beam objects.

\item[{Examples:}] \leavevmode
Accepts all surface or surface-derived object inputs, though all data 
is stored as a python object.

Generate an y direction Ray in cartesian coords using a Vec from (0,0,1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cen} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Center}\PYG{p}{(}\PYG{n}{flag}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ydir} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Vecx}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zpt} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Point}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{cen}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{volWeightBeam() (in module TRIPPy.beam)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.beam.volWeightBeam}\pysiglinewithargsret{\code{TRIPPy.beam.}\bfcode{volWeightBeam}}{\emph{beam}, \emph{rgrid}, \emph{zgrid}, \emph{trace=True}, \emph{ds=0.002}, \emph{toroidal=None}, \emph{**kwargs}}{}
Generate a tuple of Beam objects from tuples of surface objects
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{beam: tuple of Surfaces or a Surface object}] \leavevmode
Beam origin surfaces, based on the coordinate system
of the surfaces.  Center position is accessible through Beam(0),
Beam.x(){[}...,0{]} or Beam.r(){[}...,0{]} (last two options create
numpy arrays, the first generats a geometry.Vec object).

\item[{rgrid: tuple of Surfaces or a Surface object}] \leavevmode
Direction of the ray can be defined by a vector object (assumed
to be in the space of the pt1 origin) from pt1, or a point, which 
generates a vector pointing from pt1 to pt2.

\item[{zgrid: tuple of Surfaces or a Surface object}] \leavevmode
Direction of the ray can be defined by a vector object (assumed
to be in the space of the pt1 origin) from pt1, or a point, which 
generates a vector pointing from pt1 to pt2.

\end{description}

\item[{Returns:}] \leavevmode
output: tuple of beam objects.

\item[{Examples:}] \leavevmode
Accepts all surface or surface-derived object inputs, though all data 
is stored as a python object.

Generate an y direction Ray in cartesian coords using a Vec from (0,0,1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cen} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Center}\PYG{p}{(}\PYG{n}{flag}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ydir} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Vecx}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zpt} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Point}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{cen}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}



\chapter{TRIPPy.geometry module}
\label{TRIPPy:trippy-geometry-module}\label{TRIPPy:module-TRIPPy.geometry}\index{TRIPPy.geometry (module)}\index{Center (class in TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Center}\pysiglinewithargsret{\strong{class }\code{TRIPPy.geometry.}\bfcode{Center}}{\emph{flag=True}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.geometry.Origin]{\code{TRIPPy.geometry.Origin}}}

Center object with inherent cartesian backend mathematics.

Creates a new Center instance which can be set to a default 
coordinate system of cartesian or cylindrical coordinates.
All vector mathematics are accomplished in cartesian to 
simplify computation effort. Cylindrical vectors are
converted at last step for return.  It defaults to cylindrical
coordinates

The Center class which underlies all positional calculation.
It is located at (0,0,0) and is inherently a cylindrical coordinate
system (unless flag set otherwise). It is from the translation
of inherently cylindrical data into toroidal coordinates 
requires this rosetta stone, it can be dynamically set to 
becoming an origin given a specification of another origin.
\begin{description}
\item[{Kwargs:}] \leavevmode\begin{description}
\item[{flag: Boolean.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate a Center in cylindrical coordinates:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
\end{quote}

Generate a Center in cartesian coordinates:
\begin{quote}

cent = Center(flag=False)
\end{quote}

\end{description}
\index{meri (TRIPPy.geometry.Center attribute)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Center.meri}\pysigline{\bfcode{meri}\strong{ = \textless{}TRIPPy.geometry.Vec object at 0x3e73c90\textgreater{}}}
\end{fulllineitems}

\index{norm (TRIPPy.geometry.Center attribute)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Center.norm}\pysigline{\bfcode{norm}\strong{ = \textless{}TRIPPy.geometry.Vec object at 0x3e73cd0\textgreater{}}}
\end{fulllineitems}

\index{sagi (TRIPPy.geometry.Center attribute)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Center.sagi}\pysigline{\bfcode{sagi}\strong{ = \textless{}TRIPPy.geometry.Vec object at 0x3e73bd0\textgreater{}}}
\end{fulllineitems}


\end{fulllineitems}

\index{Origin (class in TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Origin}\pysiglinewithargsret{\strong{class }\code{TRIPPy.geometry.}\bfcode{Origin}}{\emph{x\_hat}, \emph{ref=None}, \emph{vec=None}, \emph{angle=None}, \emph{flag=None}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.geometry.Point]{\code{TRIPPy.geometry.Point}}}

Origin object with inherent cartesian backend mathematics.

Creates a new Origin instance which can be set to a default 
coordinate system of cartesian or cylindrical coordinates.
All vector mathematics are accomplished in cartesian to 
simplify computation effort. Cylindrical vectors are
converted at last step for return.

An Origin is defined by a point and two vectors. The two 
vectors being: 1st the normal to the surface, principal axis,
z-vector or the (0,0,1) vector of the new system defined in
the reference system. The second vector along with the 
first fully defines meridonial ray paths, y-vector or the
(0,1,0) vector (.meri). The sagittal ray path, x-vector or
the (1,0,0) is defined through a cross product (.sagi).
Point position and rotation matricies are stored at
instantiation.

These conventions of norm to z, meri to y axis and sagi to
x axis are exactly as perscribed in the OSLO optical code,
allowing for easier translation from its data into Toroidal
systems.

If the angles alpha, beta, and gamma are specified following
the eulerian rotation formalism, it is processed in the 
following manner: alpha is the rotation from the principal
axis in the meridonial plane, beta is the rotation about the
plane normal to the meridonial ray, or 2nd specified vector,
and gamma is the 2nd rotation about the principal axis. 
This might change based on what is most physically intuitive.
These are converted to vectors and stored as attributes.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x\_hat: geometry-derived object or Array-like of size 3 or 3xN.}] \leavevmode
Position in the coordinate system defined by origin, 
which, if it is a scipy array, follows the input convention
of the origin. Specified vector will be converted as necessary.

\end{description}

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{ref: Origin or Origin-derived object.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\item[{vec: Tuple of two Vector objects}] \leavevmode
The two vectors describe the normal (or z) axis and
the meridonial (or y) axis. Inputs should follow
{[}meri,normal{]}. If not specified, it assumed that angle
is specified.

\item[{angle: tuple or array of 3 floats}] \leavevmode
alpha, beta and gamma are eulerian rotation angles which
describe the rotation and thus the sagittal and 
meridonial rays.

\item[{flag: Boolean.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
newy = Vecr((1.,scipy.pi,0.))
z = Vecr((0.,0.,1.))
ex = Origin((0.,0.,0.), cent, vec={[}newy,z{]})
\end{quote}

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
ex1 = Origin((0.,0.,0.), cent, angle=(scipy.pi/2,0.,0.))
\end{quote}

Generate an origin at (1,10,-7) with a cartesian coord system:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
place = Vecx((1.,10.,-7.))
ex2 = Origin(place, cent, angle=(0.,0.,0.), flag=False)
\end{quote}

Generate an origin at (1,1,1) with a cartesian coord system:
\begin{quote}

cent = Center(flag=False) \#cartesian coords.
ex3 = Origin((1.,1.,1.), cent, angle=(0.,0.,0.))
\end{quote}

\end{description}
\index{arot() (TRIPPy.geometry.Origin method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Origin.arot}\pysiglinewithargsret{\bfcode{arot}}{\emph{vec}}{}
Rotate vector out of coordinates of Origin.
(Anti-Rotate)

Inverse of rot() function
\begin{description}
\item[{Args:}] \leavevmode
vec: Vector or Vector-derived object

\end{description}

\end{fulllineitems}

\index{redefine() (TRIPPy.geometry.Origin method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Origin.redefine}\pysiglinewithargsret{\bfcode{redefine}}{\emph{neworigin}}{}
redefine Origin object or Origin-derived object
into new coordinate system
\begin{description}
\item[{Args:}] \leavevmode
neworigin: Origin or Origin-derived object

\end{description}

\end{fulllineitems}

\index{rot() (TRIPPy.geometry.Origin method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Origin.rot}\pysiglinewithargsret{\bfcode{rot}}{\emph{vec}}{}
Rotate input vector objects into coordinates of Origin.
\begin{description}
\item[{Args:}] \leavevmode
vec: Vector object

\end{description}

\end{fulllineitems}

\index{spin() (TRIPPy.geometry.Origin method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Origin.spin}\pysiglinewithargsret{\bfcode{spin}}{\emph{angle}}{}
Spin vector or vector-derived object around Origin
about the cylindrical (0,0,1)/norm vector axis. This function
is different from rot.
\begin{description}
\item[{Args:}] \leavevmode
vec: Vector or Vector-derived object

\end{description}

\end{fulllineitems}

\index{split() (TRIPPy.geometry.Origin method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Origin.split}\pysiglinewithargsret{\bfcode{split}}{\emph{*args}, \emph{**kwargs}}{}
split coordinate values into seperate objects
\begin{description}
\item[{Kwargs:}] \leavevmode\begin{description}
\item[{obj: geometry-derived object which to form from data.}] \leavevmode
If not specified, returns a tuple of Origin objects.

\end{description}

\item[{Returns:}] \leavevmode
Object tuple size N for N points. Works to arbitrary
dimension.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Point (class in TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Point}\pysiglinewithargsret{\strong{class }\code{TRIPPy.geometry.}\bfcode{Point}}{\emph{x\_hat}, \emph{ref=None}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.geometry.Vec]{\code{TRIPPy.geometry.Vec}}}

Point object with inherent cartesian backend mathematics.

Creates a new Point instance which is set to a default 
coordinate system of cartesian or cylindrical coordinates
determined from the reference coordinate system. All vector
mathematics are accomplished in cartesian to simplify 
computation effort. Cylindrical vectors are converted at
last step for return.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x\_hat: geometry object or 3xN coordinate system values.}] \leavevmode
Input coordinate system value options assume that
it matches the coordinate system of the reference
origin.

\end{description}

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{ref: Origin object.}] \leavevmode
Sets the default coordinate nature

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though
all data is stored in numpy arrays.

Generate a point 1m in x from point U (xdir):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{xdir} \PYG{o}{=} \PYG{n}{Vec}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)} \PYG{c}{\PYGZsh{}implicitly in cyl. coords.}
\end{Verbatim}

Generate a cartesian point into direction (2,2,2) from Q:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec2} \PYG{o}{=} \PYG{n}{Vec}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ref}\PYG{o}{=}\PYG{n}{Q}\PYG{p}{)}
\end{Verbatim}

Generate a cylindrical radial vector (vec2) into direction (1,0,1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cent} \PYG{o}{=} \PYG{n}{Center}\PYG{p}{(}\PYG{p}{)} \PYG{c}{\PYGZsh{}implicitly in cyl. coords.}
\PYG{n}{vec2} \PYG{o}{=} \PYG{n}{Vec}\PYG{p}{(}\PYG{n}{vec1}\PYG{p}{,} \PYG{n}{ref}\PYG{o}{=}\PYG{n}{cent}\PYG{p}{)}
\end{Verbatim}

\end{description}
\index{c() (TRIPPy.geometry.Point method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Point.c}\pysiglinewithargsret{\bfcode{c}}{}{}
\end{fulllineitems}

\index{redefine() (TRIPPy.geometry.Point method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Point.redefine}\pysiglinewithargsret{\bfcode{redefine}}{\emph{neworigin}}{}
redefine Point object or Point-derived object
into new coordinate system
\begin{description}
\item[{Args:}] \leavevmode
neworigin: Origin or Origin-derived object

\end{description}

\end{fulllineitems}

\index{split() (TRIPPy.geometry.Point method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Point.split}\pysiglinewithargsret{\bfcode{split}}{\emph{*args}, \emph{**kwargs}}{}
split coordinate values into seperate objects
\begin{description}
\item[{Kwargs:}] \leavevmode
obj: geometry-derived object which to form from data

\item[{Returns:}] \leavevmode
Object tuple size N for N points. Works to arbitrary
dimension.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Vec (class in TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec}\pysiglinewithargsret{\strong{class }\code{TRIPPy.geometry.}\bfcode{Vec}}{\emph{x\_hat}, \emph{s}, \emph{flag=False}}{}
Bases: \code{object}

Vector object with inherent cartesian backend mathematics.

Creates a new Vec instance which can be set to a default 
coordinate system of cartesian or cylindrical coordinates.
All vector mathematics are accomplished in cartesian to 
simplify computation effort. Cylindrical vectors are
converted at last step for return.

It is highly recommended to utilize the Vecx and Vecr 
functions which allow for proper data checks in generating
vectors.
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x\_hat: Array-like of size 3 or 3xN in cartesian.}] \leavevmode
for all i, x\_hat{[}0{]}{[}i{]}**2 + x\_hat{[}1{]}{[}i{]}**2 + x\_hat{[}2{]}{[}i{]}**2
is equal to 1.

\item[{s: Array-like of size 1 or shape N.}] \leavevmode
Values of the positions of the 2nd
dimension of f. Must be monotonic without duplicates.

\end{description}

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{flag: Boolean.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though
all data is stored in numpy arrays.

Generate an x direction unit vector (xdir):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{xdir} \PYG{o}{=} \PYG{n}{Vec}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec1) into direction (2,2,2):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec1} \PYG{o}{=} \PYG{n}{Vec}\PYG{p}{(}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{3.0}\PYG{p}{,}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec2) into direction (4,4,4):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec2} \PYG{o}{=} \PYG{n}{Vec}\PYG{p}{(}\PYG{n}{vec1}\PYG{o}{.}\PYG{n}{unit}\PYG{p}{,}\PYG{n}{vec1}\PYG{o}{.}\PYG{n}{s}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

\end{description}
\index{c() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.c}\pysiglinewithargsret{\bfcode{c}}{}{}
Conversion of vector to opposite coordinate system
\begin{description}
\item[{Returns:}] \leavevmode
copy of vector object with opposite coordinate system
(set with .flag parameter)

\end{description}

\end{fulllineitems}

\index{copy() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
copy of object
\begin{description}
\item[{Returns:}] \leavevmode
copy of object

\end{description}

\end{fulllineitems}

\index{point() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.point}\pysiglinewithargsret{\bfcode{point}}{\emph{ref}}{}
returns point based off of vector
\begin{description}
\item[{Args:}] \leavevmode
ref: reference origin

\item[{Returns:}] \leavevmode
Point object

\end{description}

\end{fulllineitems}

\index{r() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.r}\pysiglinewithargsret{\bfcode{r}}{}{}
return cylindrical coordinate values
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in meters and radians

\end{description}

\end{fulllineitems}

\index{r0() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.r0}\pysiglinewithargsret{\bfcode{r0}}{}{}
returns cylindrical coordinate along first dimension
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in meters

\end{description}

\end{fulllineitems}

\index{r1() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.r1}\pysiglinewithargsret{\bfcode{r1}}{}{}
returns cylindrical coordinate along second dimension
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in radians

\end{description}

\end{fulllineitems}

\index{r2() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.r2}\pysiglinewithargsret{\bfcode{r2}}{}{}
returns cylindrical coordinate along third dimension
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in meters

\end{description}

\end{fulllineitems}

\index{spin() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.spin}\pysiglinewithargsret{\bfcode{spin}}{\emph{angle}}{}
Spin vector object about the cylindrical (0,0,1)/norm vector
axis. This function is different from rot.
\begin{description}
\item[{Args:}] \leavevmode
angle: Singule element float or scipy array.

\end{description}

\end{fulllineitems}

\index{t() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.t}\pysiglinewithargsret{\bfcode{t}}{\emph{r}, \emph{z}}{}
return toroidal coordinate values for given cylindrical
coordinates (r,z).
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{r: scipy-array of floats or float in meters. r is}] \leavevmode
specified in meters.

\item[{z: scipy-array of floats or float in meters. z is}] \leavevmode
specified in meters.

\end{description}

\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in {[}meters,radians,radians{]}
where it is radius in meters, toroidal angle and then poloidal angle.

\end{description}

\end{fulllineitems}

\index{t0() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.t0}\pysiglinewithargsret{\bfcode{t0}}{\emph{r}, \emph{z}}{}
returns toroidal distance given cylindrical
coordinates (r,z).
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{r: scipy-array of floats or float in meters. r is}] \leavevmode
specified in meters.

\item[{z: scipy-array of floats or float in meters. z is}] \leavevmode
specified in meters.

\end{description}

\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in meters

\end{description}

\end{fulllineitems}

\index{t2() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.t2}\pysiglinewithargsret{\bfcode{t2}}{\emph{r}, \emph{z}}{}
returns poloidal angle given cylindrical
coordinates (r,z)
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{r: scipy-array of floats or float in meters. r is}] \leavevmode
specified in meters.

\item[{z: scipy-array of floats or float in meters. z is}] \leavevmode
specified in meters.

\end{description}

\item[{Returns:}] \leavevmode
numpy array of cylindrical coordinates in meters

\end{description}

\end{fulllineitems}

\index{x() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.x}\pysiglinewithargsret{\bfcode{x}}{}{}
return cartesian coordinate values
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cartesian coordinates in meters

\end{description}

\end{fulllineitems}

\index{x0() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.x0}\pysiglinewithargsret{\bfcode{x0}}{}{}
returns cartesian coordinate along first dimension
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cartesian coordinates in meters

\end{description}

\end{fulllineitems}

\index{x1() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.x1}\pysiglinewithargsret{\bfcode{x1}}{}{}
returns cartesian coordinate along second dimension
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cartesian coordinates in meters

\end{description}

\end{fulllineitems}

\index{x2() (TRIPPy.geometry.Vec method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vec.x2}\pysiglinewithargsret{\bfcode{x2}}{}{}
returns cartesian coordinate along third dimension
\begin{description}
\item[{Returns:}] \leavevmode
numpy array of cartesian coordinates in meters

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{Vecr() (in module TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vecr}\pysiglinewithargsret{\code{TRIPPy.geometry.}\bfcode{Vecr}}{\emph{x\_hat}, \emph{s=None}}{}
Generates a cylindrical coordinate vector object

Uses the definition:
\begin{gather}
\begin{split}\vec{x}= \texttt{xhat}[0]\hat{r} + \texttt{xhat}[1]\hat{\theta} + \texttt{xhat}[2]\hat{z}\end{split}\notag
\end{gather}
Capable of storing multiple directions and lengths as a single
vector, but highly discouraged (from POLS).
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x\_hat: Array-like, 3 or 3xN.}] \leavevmode
3 dimensional cylindrical vector input, which is stores the 
direction and magnitude as seperate values.  All values of 
theta will be aliased to $(\pi,\pi]$

\end{description}

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{s: Array-like or scalar float.}] \leavevmode
Vector magnitude in meters. When specified, it is assumed that 
x\_hat is representative of direction only and is of unit
length. Saves in computation as length calculation avoided.

\end{description}

\item[{Returns:}] \leavevmode
Vec: Vector object.

\item[{Examples:}] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate an y direction unit vector in cylindrical coords (ydir):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ydir} \PYG{o}{=} \PYG{n}{Vecr}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec1) into direction (1,pi/3,-4):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec1} \PYG{o}{=} \PYG{n}{Vecr}\PYG{p}{(}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mf}{4.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec2) into direction (6,0,8):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec2} \PYG{o}{=} \PYG{n}{Vecr}\PYG{p}{(}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{3.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{4.}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{5.0}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec3) into direction (.3,0,.4):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec3} \PYG{o}{=} \PYG{n}{Vecr}\PYG{p}{(}\PYG{n}{vec2}\PYG{o}{.}\PYG{n}{r}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{vec2}\PYG{o}{.}\PYG{n}{s}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{Vecx() (in module TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.Vecx}\pysiglinewithargsret{\code{TRIPPy.geometry.}\bfcode{Vecx}}{\emph{x\_hat}, \emph{s=None}}{}
Generates a cartesian coordinate vector object

Uses the definition:
\begin{gather}
\begin{split}\vec{x}= \texttt{xhat}[0]\hat{x} + \texttt{xhat}[1]\hat{y} + \texttt{xhat}[2]\hat{z}\end{split}\notag
\end{gather}
Capable of storing multiple directions and lengths as a single
vector, but highly discouraged (from POLS).
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x\_hat: Array-like, 3 or 3xN.}] \leavevmode
3 dimensional cartesian vector input, which is stores the 
direction and magnitude as seperate values.

\end{description}

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{s: Array-like or scalar float.}] \leavevmode
Vector magnitude in meters. When specified, it is assumed that 
x\_hat is representative of direction only and is of unit
length. Saves in computation as length calculation is avoided.

\end{description}

\item[{Returns:}] \leavevmode
Vec: Vector object.

\item[{Examples:}] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate an x direction unit vector (xdir):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{xdir} \PYG{o}{=} \PYG{n}{Vecx}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec1) into direction (1,3,-4):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec1} \PYG{o}{=} \PYG{n}{Vecx}\PYG{p}{(}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{3.}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mf}{4.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec2) into direction (2,2,2):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec2} \PYG{o}{=} \PYG{n}{Vecx}\PYG{p}{(}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{3.0}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Generate a cartesian vector (vec3) into direction (3,3,3):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vec3} \PYG{o}{=} \PYG{n}{Vecx}\PYG{p}{(}\PYG{n}{vec2}\PYG{o}{.}\PYG{n}{unit}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{n}{scipy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{l+m+mf}{3.0}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}

\index{angle() (in module TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.angle}\pysiglinewithargsret{\code{TRIPPy.geometry.}\bfcode{angle}}{\emph{Vec1}, \emph{Vec2}}{}
Returns angle between two vectors.
\begin{description}
\item[{Args:}] \leavevmode
Vec1: Vec Object

Vec2: Vec Object

\item[{Returns:}] \leavevmode
angle in radians $[0,\pi]$ seperating the two vectors
on the plane defined by the two.

\end{description}

\end{fulllineitems}

\index{cross() (in module TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.cross}\pysiglinewithargsret{\code{TRIPPy.geometry.}\bfcode{cross}}{\emph{Vec1}, \emph{Vec2}}{}
Returns angle between two vectors.
\begin{description}
\item[{Args:}] \leavevmode
Vec1: Vec Object

Vec2: Vec Object

\item[{Returns:}] \leavevmode
Vec object of the vector cross product of the two vectors.
It is in the coordinate system of the first argument.

\end{description}

\end{fulllineitems}

\index{fill() (in module TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.fill}\pysiglinewithargsret{\code{TRIPPy.geometry.}\bfcode{fill}}{\emph{funtype}, \emph{x0}, \emph{x1}, \emph{x2}, \emph{*args}, \emph{**kwargs}}{}
Recursive function to generate TRIPPy Objects
\begin{description}
\item[{Args:}] \leavevmode
funtype: Object type to replicate

x0: coordinate of 1st direction

x1: coordinate of 2md direction

x2: coordinate of 3rd direction

\item[{Returns:}] \leavevmode
Tuple or object of type funtype.

\end{description}

\end{fulllineitems}

\index{pts2Vec() (in module TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.pts2Vec}\pysiglinewithargsret{\code{TRIPPy.geometry.}\bfcode{pts2Vec}}{\emph{pt1}, \emph{pt2}}{}
Returns angle between two vectors.
\begin{description}
\item[{Args:}] \leavevmode
pt1: geometry Object with reference origin

pt2: geometry Object with reference origin

\item[{Returns:}] \leavevmode
Vector object: Vector points from pt1 to pt2.

\end{description}

\end{fulllineitems}

\index{unit() (in module TRIPPy.geometry)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.geometry.unit}\pysiglinewithargsret{\code{TRIPPy.geometry.}\bfcode{unit}}{\emph{x\_hat}}{}
Checks vector input to be of correct array dimensionality.

Numpy array dimensionality can often create unexpected array sizes
in multiplications. Unit also forces the input to follow unit 
vector conventions. It checks the expected cartesian unit 
vector to be 3xN, and that all elements of x\_hat are within the
range {[}-1,1{]}
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{x\_hat: Array-like, 3 or 3xN.}] \leavevmode
3 dimensional cartesian vector input, which is stores the 
direction and magnitude as seperate values.

\end{description}

\item[{Returns:}] \leavevmode
Vec: Vector object.

\item[{Examples:}] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Check {[}1.,0.,0.{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{xdir} \PYG{o}{=} \PYG{n}{unit}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Check {[}{[}1.,2.{]},{[}0.,0.{]},{[}0.,0{]}{]}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{xdir} \PYG{o}{=} \PYG{n}{unit}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\item[{Raises:}] \leavevmode\begin{description}
\item[{ValueError: If any of the dimensions of x\_hat are not 3xN or not}] \leavevmode
of unit length.

\end{description}

\end{description}

\end{fulllineitems}



\chapter{TRIPPy.invert module}
\label{TRIPPy:module-TRIPPy.invert}\label{TRIPPy:trippy-invert-module}\index{TRIPPy.invert (module)}\index{rhosens() (in module TRIPPy.invert)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.invert.rhosens}\pysiglinewithargsret{\code{TRIPPy.invert.}\bfcode{rhosens}}{\emph{beams}, \emph{plasma}, \emph{time}, \emph{points}, \emph{step=0.001}, \emph{meth='psinorm'}}{}
optimal to give multiple times

\end{fulllineitems}

\index{sens() (in module TRIPPy.invert)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.invert.sens}\pysiglinewithargsret{\code{TRIPPy.invert.}\bfcode{sens}}{\emph{beams}, \emph{plasmameth}, \emph{time}, \emph{points}, \emph{step=0.001}}{}
optimal to give multiple times

\end{fulllineitems}



\chapter{TRIPPy.plasma module}
\label{TRIPPy:module-TRIPPy.plasma}\label{TRIPPy:trippy-plasma-module}\index{TRIPPy.plasma (module)}\index{Tokamak (class in TRIPPy.plasma)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.plasma.Tokamak}\pysiglinewithargsret{\strong{class }\code{TRIPPy.plasma.}\bfcode{Tokamak}}{\emph{equilib}, \emph{flag=True}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.geometry.Center]{\code{TRIPPy.geometry.Center}}}
\index{getMachineCrossSection() (TRIPPy.plasma.Tokamak method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.plasma.Tokamak.getMachineCrossSection}\pysiglinewithargsret{\bfcode{getMachineCrossSection}}{}{}
\end{fulllineitems}

\index{getVessel() (TRIPPy.plasma.Tokamak method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.plasma.Tokamak.getVessel}\pysiglinewithargsret{\bfcode{getVessel}}{\emph{idx}, \emph{pts=250}}{}
\end{fulllineitems}

\index{gridWeight() (TRIPPy.plasma.Tokamak method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.plasma.Tokamak.gridWeight}\pysiglinewithargsret{\bfcode{gridWeight}}{\emph{beams}, \emph{rgrid=None}, \emph{zgrid=None}, \emph{spacing=0.001}}{}
this method finds the weighting of the view on a poloidal plane
it takes a beam and traces it through the plasma

\end{fulllineitems}

\index{inVessel() (TRIPPy.plasma.Tokamak method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.plasma.Tokamak.inVessel}\pysiglinewithargsret{\bfcode{inVessel}}{\emph{ptin}}{}
\end{fulllineitems}

\index{pnt2RhoTheta() (TRIPPy.plasma.Tokamak method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.plasma.Tokamak.pnt2RhoTheta}\pysiglinewithargsret{\bfcode{pnt2RhoTheta}}{\emph{point}, \emph{t=0}, \emph{method='psinorm'}, \emph{n=0}, \emph{poloidal\_plane=0}}{}
takes r,theta,z and the plasma, and map it to the toroidal position
this will be replaced by a toroidal point generating system based of
a seperate vector class

\end{fulllineitems}

\index{trace() (TRIPPy.plasma.Tokamak method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.plasma.Tokamak.trace}\pysiglinewithargsret{\bfcode{trace}}{\emph{ray}, \emph{limiter=0}}{}
\end{fulllineitems}


\end{fulllineitems}



\chapter{TRIPPy.surface module}
\label{TRIPPy:trippy-surface-module}\label{TRIPPy:module-TRIPPy.surface}\index{TRIPPy.surface (module)}\index{Circle (class in TRIPPy.surface)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Circle}\pysiglinewithargsret{\strong{class }\code{TRIPPy.surface.}\bfcode{Circle}}{\emph{x\_hat}, \emph{ref}, \emph{radius}, \emph{vec=None}, \emph{angle=None}, \emph{flag=None}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.surface.Ellipse]{\code{TRIPPy.surface.Ellipse}}}

Origin object with inherent cartesian backend mathematics.

Creates a new Origin instance which can be set to a default 
coordinate system of cartesian or cylindrical coordinates.
All vector mathematics are accomplished in cartesian to 
simplify computation effort. Cylindrical vectors are
converted at last step for return.

An Origin is defined by a point and two vectors. The two 
vectors being: 1st the normal to the surface, principal axis,
z-vector or the (0,0,1) vector of the new system defined in
the reference system. The second vector along with the 
first fully defines meridonial ray paths, y-vector or the
(0,1,0) vector (.meri). The sagittal ray path, x-vector or
the (1,0,0) is defined through a cross product (.sagi).
Point position and rotation matricies are stored at
instantiation.

These conventions of norm to z, meri to y axis and sagi to
x axis are exactly as perscribed in the OSLO optical code,
allowing for easier translation from its data into Toroidal
systems.

If the angles alpha, beta, and gamma are specified following
the eulerian rotation formalism, it is processed in the 
following manner: alpha is the rotation from the principal
axis in the meridonial plane, beta is the rotation about the
plane normal to the meridonial ray, or 2nd specified vector,
and gamma is the 2nd rotation about the principal axis. 
This might change based on what is most physically intuitive.
These are converted to vectors and stored as attributes.
\begin{description}
\item[{Args:}] \leavevmode
x\_hat: geometry-derived object or Array-like of size 3 or 3xN.

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{ref: Origin or Origin-derived object.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\item[{vec: Tuple of two Vector objects}] \leavevmode
The two vectors describe the normal (or z) axis and
the meridonial (or y) axis. Inputs should follow
{[}meri,normal{]}. If not specified, it assumed that angle
is specified.

\item[{angle: tuple or array of 3 floats}] \leavevmode
alpha, beta and gamma are eulerian rotation angles which
describe the rotation and thus the sagittal and 
meridonial rays.

\item[{flag: Boolean.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
newy = Vecr((1.,scipy.pi,0.))
z = Vecr((0.,0.,1.))
ex = Origin((0.,0.,0.), cent, vec={[}newy,z{]})
\end{quote}

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
ex1 = Origin((0.,0.,0.), cent, angle=(scipy.pi/2,0.,0.))
\end{quote}

Generate an origin at (1,10,-7) with a cartesian coord system:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
place = Vecx((1.,10.,-7.))
ex2 = Origin(place, cent, angle=(0.,0.,0.), flag=False)
\end{quote}

Generate an origin at (1,1,1) with a cartesian coord system:
\begin{quote}

cent = Center(flag=False) \#cartesian coords.
ex3 = Origin((1.,1.,1.), cent, angle=(0.,0.,0.))
\end{quote}

\end{description}
\index{area() (TRIPPy.surface.Circle method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Circle.area}\pysiglinewithargsret{\bfcode{area}}{\emph{radius=None}}{}
\end{fulllineitems}

\index{edgetest() (TRIPPy.surface.Circle method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Circle.edgetest}\pysiglinewithargsret{\bfcode{edgetest}}{\emph{radius=None}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Ellipse (class in TRIPPy.surface)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Ellipse}\pysiglinewithargsret{\strong{class }\code{TRIPPy.surface.}\bfcode{Ellipse}}{\emph{x\_hat}, \emph{ref}, \emph{area}, \emph{vec=None}, \emph{angle=None}, \emph{flag=None}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.surface.Surf]{\code{TRIPPy.surface.Surf}}}

Origin object with inherent cartesian backend mathematics.

Creates a new Origin instance which can be set to a default 
coordinate system of cartesian or cylindrical coordinates.
All vector mathematics are accomplished in cartesian to 
simplify computation effort. Cylindrical vectors are
converted at last step for return.

An Origin is defined by a point and two vectors. The two 
vectors being: 1st the normal to the surface, principal axis,
z-vector or the (0,0,1) vector of the new system defined in
the reference system. The second vector along with the 
first fully defines meridonial ray paths, y-vector or the
(0,1,0) vector (.meri). The sagittal ray path, x-vector or
the (1,0,0) is defined through a cross product (.sagi).
Point position and rotation matricies are stored at
instantiation.

These conventions of norm to z, meri to y axis and sagi to
x axis are exactly as perscribed in the OSLO optical code,
allowing for easier translation from its data into Toroidal
systems.

If the angles alpha, beta, and gamma are specified following
the eulerian rotation formalism, it is processed in the 
following manner: alpha is the rotation from the principal
axis in the meridonial plane, beta is the rotation about the
plane normal to the meridonial ray, or 2nd specified vector,
and gamma is the 2nd rotation about the principal axis. 
This might change based on what is most physically intuitive.
These are converted to vectors and stored as attributes.
\begin{description}
\item[{Args:}] \leavevmode
x\_hat: geometry-derived object or Array-like of size 3 or 3xN.

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{ref: Origin or Origin-derived object.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\item[{vec: Tuple of two Vector objects}] \leavevmode
The two vectors describe the normal (or z) axis and
the meridonial (or y) axis. Inputs should follow
{[}meri,normal{]}. If not specified, it assumed that angle
is specified.

\item[{angle: tuple or array of 3 floats}] \leavevmode
alpha, beta and gamma are eulerian rotation angles which
describe the rotation and thus the sagittal and 
meridonial rays.

\item[{flag: Boolean.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
newy = Vecr((1.,scipy.pi,0.))
z = Vecr((0.,0.,1.))
ex = Origin((0.,0.,0.), cent, vec={[}newy,z{]})
\end{quote}

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
ex1 = Origin((0.,0.,0.), cent, angle=(scipy.pi/2,0.,0.))
\end{quote}

Generate an origin at (1,10,-7) with a cartesian coord system:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
place = Vecx((1.,10.,-7.))
ex2 = Origin(place, cent, angle=(0.,0.,0.), flag=False)
\end{quote}

Generate an origin at (1,1,1) with a cartesian coord system:
\begin{quote}

cent = Center(flag=False) \#cartesian coords.
ex3 = Origin((1.,1.,1.), cent, angle=(0.,0.,0.))
\end{quote}

\end{description}
\index{area() (TRIPPy.surface.Ellipse method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Ellipse.area}\pysiglinewithargsret{\bfcode{area}}{\emph{sagi=None}, \emph{meri=None}}{}
\end{fulllineitems}

\index{edge() (TRIPPy.surface.Ellipse method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Ellipse.edge}\pysiglinewithargsret{\bfcode{edge}}{\emph{angle={[}0, 6.283185307179586{]}, pts=250}}{}
\end{fulllineitems}

\index{edgetest() (TRIPPy.surface.Ellipse method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Ellipse.edgetest}\pysiglinewithargsret{\bfcode{edgetest}}{\emph{meri}, \emph{sagi}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Rect (class in TRIPPy.surface)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Rect}\pysiglinewithargsret{\strong{class }\code{TRIPPy.surface.}\bfcode{Rect}}{\emph{x\_hat}, \emph{ref}, \emph{area}, \emph{vec=None}, \emph{angle=None}, \emph{flag=None}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.surface.Surf]{\code{TRIPPy.surface.Surf}}}

Origin object with inherent cartesian backend mathematics.

Creates a new Origin instance which can be set to a default 
coordinate system of cartesian or cylindrical coordinates.
All vector mathematics are accomplished in cartesian to 
simplify computation effort. Cylindrical vectors are
converted at last step for return.

An Origin is defined by a point and two vectors. The two 
vectors being: 1st the normal to the surface, principal axis,
z-vector or the (0,0,1) vector of the new system defined in
the reference system. The second vector along with the 
first fully defines meridonial ray paths, y-vector or the
(0,1,0) vector (.meri). The sagittal ray path, x-vector or
the (1,0,0) is defined through a cross product (.sagi).
Point position and rotation matricies are stored at
instantiation.

These conventions of norm to z, meri to y axis and sagi to
x axis are exactly as perscribed in the OSLO optical code,
allowing for easier translation from its data into Toroidal
systems.

If the angles alpha, beta, and gamma are specified following
the eulerian rotation formalism, it is processed in the 
following manner: alpha is the rotation from the principal
axis in the meridonial plane, beta is the rotation about the
plane normal to the meridonial ray, or 2nd specified vector,
and gamma is the 2nd rotation about the principal axis. 
This might change based on what is most physically intuitive.
These are converted to vectors and stored as attributes.
\begin{description}
\item[{Args:}] \leavevmode
x\_hat: geometry-derived object or Array-like of size 3 or 3xN.

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{ref: Origin or Origin-derived object.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\item[{vec: Tuple of two Vector objects}] \leavevmode
The two vectors describe the normal (or z) axis and
the meridonial (or y) axis. Inputs should follow
{[}meri,normal{]}. If not specified, it assumed that angle
is specified.

\item[{angle: tuple or array of 3 floats}] \leavevmode
alpha, beta and gamma are eulerian rotation angles which
describe the rotation and thus the sagittal and 
meridonial rays.

\item[{flag: Boolean.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
newy = Vecr((1.,scipy.pi,0.))
z = Vecr((0.,0.,1.))
ex = Origin((0.,0.,0.), cent, vec={[}newy,z{]})
\end{quote}

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
ex1 = Origin((0.,0.,0.), cent, angle=(scipy.pi/2,0.,0.))
\end{quote}

Generate an origin at (1,10,-7) with a cartesian coord system:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
place = Vecx((1.,10.,-7.))
ex2 = Origin(place, cent, angle=(0.,0.,0.), flag=False)
\end{quote}

Generate an origin at (1,1,1) with a cartesian coord system:
\begin{quote}

cent = Center(flag=False) \#cartesian coords.
ex3 = Origin((1.,1.,1.), cent, angle=(0.,0.,0.))
\end{quote}

\end{description}
\index{area() (TRIPPy.surface.Rect method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Rect.area}\pysiglinewithargsret{\bfcode{area}}{\emph{sagi=None}, \emph{meri=None}}{}
\end{fulllineitems}

\index{edge() (TRIPPy.surface.Rect method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Rect.edge}\pysiglinewithargsret{\bfcode{edge}}{}{}
return points at the edge of rectangle

\end{fulllineitems}

\index{edgetest() (TRIPPy.surface.Rect method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Rect.edgetest}\pysiglinewithargsret{\bfcode{edgetest}}{\emph{sagi}, \emph{meri}}{}
\end{fulllineitems}

\index{split() (TRIPPy.surface.Rect method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Rect.split}\pysiglinewithargsret{\bfcode{split}}{\emph{sagi}, \emph{meri}}{}
utilizes geometry.grid to change the rectangle into a generalized surface,
it is specified with a single set of basis vectors to describe the meridonial,
normal, and sagittal planes.

\end{fulllineitems}


\end{fulllineitems}

\index{Surf (class in TRIPPy.surface)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Surf}\pysiglinewithargsret{\strong{class }\code{TRIPPy.surface.}\bfcode{Surf}}{\emph{x\_hat}, \emph{ref}, \emph{area}, \emph{vec=None}, \emph{angle=None}, \emph{flag=None}}{}
Bases: {\hyperref[TRIPPy:TRIPPy.geometry.Origin]{\code{TRIPPy.geometry.Origin}}}

Surf object with inherent cartesian backend mathematics.

Creates a new Surf instance which can be set to a default 
coordinate system of cartesian or cylindrical coordinates.
All vector mathematics are accomplished in cartesian to 
simplify computation effort. Cylindrical vectors are
converted at last step for return.

A surface is defined by a point and two vectors. The two 
vectors being: 1st the normal to the surface, principal axis,
z-vector or the (0,0,1) vector of the new system defined in
the reference system. The second vector along with the 
first fully defines meridonial ray paths, y-vector or the
(0,1,0) vector (.meri). The sagittal ray path, x-vector or
the (1,0,0) is defined through a cross product (.sagi).
Center position and rotation matricies are stored at
instantiation.

These conventions of norm to z, meri to y axis and sagi to
x axis are exactly as perscribed in the OSLO optical code,
allowing for easier translation from its data into Toroidal
systems.

The surface cross-sectional area is specified and used to modify
the sagittal and meridonial vectors. This is stored as lengths 
of the two vectors, meri and sagi. This object assumes that the 
surface is purely normal to the input norm vector across the
entire surface.

If the angles alpha, beta, and gamma are specified following
the eulerian rotation formalism, it is processed in the 
following manner: alpha is the rotation from the principal
axis in the meridonial plane, beta is the rotation about the
plane normal to the meridonial ray, or 2nd specified vector,
and gamma is the 2nd rotation about the principal axis. 
This might change based on what is most physically intuitive.
These are converted to vectors and stored as attributes.
\begin{description}
\item[{Args:}] \leavevmode
x\_hat: geometry-derived object or Array-like of size 3 or 3xN.
\begin{description}
\item[{ref: Origin or Origin-derived object.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\item[{area: 2-element tuple of scipy-arrays or values.}] \leavevmode
This sets the cross-sectional area of the view, which
follows the convenction {[}sagi,meri{]}. Meri is the length
in the direction of the optical axis, and sagi is the 
length in the off axis of the optical and normal axes.
Values are in meters.

\end{description}

\item[{Kwargs:}] \leavevmode\begin{description}
\item[{vec: Tuple of two Vec objects}] \leavevmode
The two vectors describe the normal (or z) axis and
the meridonial (or y) axis. Inputs should follow
{[}meri,normal{]}. If not specified, it assumed that angle
is specified.

\item[{angle: tuple or array of 3 floats}] \leavevmode
alpha, beta and gamma are eulerian rotation angles which
describe the rotation and thus the sagittal and 
meridonial rays.

\item[{flag: Boolean.}] \leavevmode
Sets the default coordinate nature of the vector to 
cartesian if False, or cylindrical if True.

\end{description}

\item[{Examples:   }] \leavevmode
Accepts all array like (tuples included) inputs, though all data 
is stored in numpy arrays.

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
newy = Vecr((1.,scipy.pi,0.))
z = Vecr((0.,0.,1.))
ex = Origin((0.,0.,0.), cent, vec={[}newy,z{]})
\end{quote}

Generate an origin at (0,0,0) with a $\pi/2$ rotation:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
ex1 = Origin((0.,0.,0.), cent, angle=(scipy.pi/2,0.,0.))
\end{quote}

Generate an origin at (1,10,-7) with a cartesian coord system:
\begin{quote}

cent = Center() \#implicitly in cyl. coords.
place = Vecx((1.,10.,-7.))
ex2 = Origin(place, cent, angle=(0.,0.,0.), flag=False)
\end{quote}

Generate an origin at (1,1,1) with a cartesian coord system:
\begin{quote}

cent = Center(flag=False) \#cartesian coords.
ex3 = Origin((1.,1.,1.), cent, angle=(0.,0.,0.))
\end{quote}

\end{description}
\index{intercept() (TRIPPy.surface.Surf method)}

\begin{fulllineitems}
\phantomsection\label{TRIPPy:TRIPPy.surface.Surf.intercept}\pysiglinewithargsret{\bfcode{intercept}}{\emph{ray}}{}
Solves for intersection point of surface and a ray or Beam
\begin{description}
\item[{Args:}] \leavevmode\begin{description}
\item[{ray: Ray or Beam object}] \leavevmode
It must be in the same coordinate space as the surface object.

\end{description}

\item[{Returns:}] \leavevmode
s: value of s {[}meters{]} which intercepts along norm, otherwise an
empty tuple (for no intersection).

\item[{Examples:}] \leavevmode
Accepts all point and point-derived object inputs, though all data 
is stored as a python object.

Generate an y direction Ray in cartesian coords using a Vec from (0,0,1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cen} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Center}\PYG{p}{(}\PYG{n}{flag}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{ydir} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Vecx}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zpt} \PYG{o}{=} \PYG{n}{geometry}\PYG{o}{.}\PYG{n}{Point}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{cen}\PYG{p}{)}
\end{Verbatim}

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Module contents}
\label{TRIPPy:module-contents}\label{TRIPPy:module-TRIPPy}\index{TRIPPy (module)}

\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{t}
\item {\texttt{TRIPPy}}, \pageref{TRIPPy:module-TRIPPy}
\item {\texttt{TRIPPy.AXUV}}, \pageref{TRIPPy:module-TRIPPy.AXUV}
\item {\texttt{TRIPPy.beam}}, \pageref{TRIPPy:module-TRIPPy.beam}
\item {\texttt{TRIPPy.BPLY}}, \pageref{TRIPPy:module-TRIPPy.BPLY}
\item {\texttt{TRIPPy.CmodTS}}, \pageref{TRIPPy:module-TRIPPy.CmodTS}
\item {\texttt{TRIPPy.geometry}}, \pageref{TRIPPy:module-TRIPPy.geometry}
\item {\texttt{TRIPPy.invert}}, \pageref{TRIPPy:module-TRIPPy.invert}
\item {\texttt{TRIPPy.NSTX}}, \pageref{TRIPPy:module-TRIPPy.NSTX}
\item {\texttt{TRIPPy.plasma}}, \pageref{TRIPPy:module-TRIPPy.plasma}
\item {\texttt{TRIPPy.plot}}, \pageref{TRIPPy.plot:module-TRIPPy.plot}
\item {\texttt{TRIPPy.plot.plot}}, \pageref{TRIPPy.plot:module-TRIPPy.plot.plot}
\item {\texttt{TRIPPy.surface}}, \pageref{TRIPPy:module-TRIPPy.surface}
\item {\texttt{TRIPPy.XTOMO}}, \pageref{TRIPPy:module-TRIPPy.XTOMO}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
